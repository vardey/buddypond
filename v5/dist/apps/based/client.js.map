{"version":3,"file":"client.js","sources":["../../../apps/based/client/client.js","../../../apps/based/client/lib/ws/createWebSocketClient.js"],"sourcesContent":["// Remark: We are migrating away from having client application, and instead moved each client to their own application's folder\n// This will be the client for messages, buddylist websocket is handled by apps/buddylist/lib/wsclient.js\n// TODO: Move this to /messages/client.js\nimport createWebSocketClient from './lib/ws/createWebSocketClient.js';\n\nexport default class Client {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.config = options.config || this.bp.config || {\n            host: \"\",\n            api: \"\",\n        };\n\n        this.api = buddypond;\n        this.api.endpoint = `${this.config.api}/api/v6`;\n\n        this.messagesWsClients = new Map();\n\n        // Track active subscriptions\n        this.subscriptions = new Map();\n\n        // Messages waiting to be sent on connection\n        this.queuedMessages = new Map();\n\n        // Timer for keepalive\n        this.keepaliveInterval = null;\n    }\n\n    async init() {\n        let config = {\n            onmessage: (event) => this.handleWorkerMessage(event),\n            onerror: (event) => console.error(\"Worker Error:\", event),\n        };\n\n        this.worker = await this.bp.createWorker('/apps/based/client/clientWorker.js', config);\n        this.worker.onmessage = (event) => {\n            this.bp.log('Message from worker:', event.data);\n            config.onmessage(event.data);\n        };\n\n        this.worker.onerror = (event) => {\n            console.error('Worker error:', event);\n            config.onerror(event);\n        };\n\n        return this;\n    }\n\n    startKeepaliveTimer() {\n        if (this.keepaliveInterval) return; // Prevent multiple intervals\n\n        this.keepaliveInterval = setInterval(() => {\n            //if (this.subscriptions.size > 0) {\n            buddypond.keepAlive();\n            this.bp.log('Keepalive ping sent');\n            //}\n        }, 30000); // 30 seconds interval\n    }\n\n    stopKeepaliveTimer() {\n        if (this.keepaliveInterval) {\n            clearInterval(this.keepaliveInterval);\n            this.keepaliveInterval = null;\n        }\n    }\n\n    sendWsMessage(chatId, message) {\n        let chatConnection = this.messagesWsClients.get(chatId);\n        if (!chatConnection || !chatConnection.wsClient) {\n            console.log('buddypond.messagesWs not connected, will queue message and send on connect...', chatId, message);\n            // open the chat window, will send queued messags on connect\n            // TODO: buddylist should accept chatId\n            let parts = chatId.split('/');\n            let buddyname = parts[1];\n            if (buddyname === this.bp.me) {\n                buddyname = parts[2];\n            }\n            console.log('parts', parts)\n            console.log('buddyname', buddyname);\n            // TODO: allow for multiple queued messages\n            this.queuedMessages.set(chatId, [message]);\n            if (parts[0] === 'buddy') {\n                this.bp.open('buddylist', {\n                    type: 'buddy',\n                    context: buddyname,\n                })\n            }\n            return;\n        }\n        // Send the message via ws connection\n        chatConnection.wsClient.send(JSON.stringify(message));\n    }\n\n    getConnectedUsers(chatId) {\n        alert('getConnectedUsers called for ' + chatId);\n        // sends a getConnectedUsers webscket message to the server\n        this.bp.log('getConnectedUsers called');\n        if (this.messagesWsClients.has(chatId)) {\n            let chatConnection = this.messagesWsClients.get(chatId);\n            if (chatConnection && chatConnection.wsClient) {\n                this.bp.log('buddypond.messagesWsClients has', chatId, 'sending getConnectedUsers message');\n                chatConnection.wsClient.send(JSON.stringify({ action: 'getConnectedUsers' }));\n            } else {\n                this.bp.log('No WebSocket client found for', chatId);\n            }\n        }\n        else {\n            this.bp.log('No WebSocket client found for', chatId, 'unable to send getConnectedUsers message');\n        }\n\n    }\n\n    addSubscription(type, context) {\n        let chatId = type + '/' + context;\n\n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n        console.log(`subscribeMessages subscribing to ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (!this.messagesWsClients.has(chatId)) {\n            this.createWebSocketClient(chatId);\n        }\n    }\n\n    removeSubscription(type, context) {\n        let chatId = type + '/' + context;\n\n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n\n        console.log(`unsubscribeMessages unsubscribing from ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (this.messagesWsClients.has(chatId)) {\n            console.log(`buddypond.messagesWsClients has ${chatId}, closing connection`);\n            let chatConnection = this.messagesWsClients.get(chatId);\n            console.log('closing chatConnection', chatConnection);\n\n            console.log('Before close, readyState:', chatConnection.wsClient.readyState);\n            chatConnection.wsClient.closeConnection();\n        }\n    }\n\n    connect() {\n        // Moved to buddylist.client.connect()\n    }\n\n    sendMessage(message) {\n        this.bp.log('sendMessage', message);\n        message.me = this.api.me;\n    }\n\n    disconnect() {\n        // Iterate through all buddypond.messagesWsClients Map and closeConnection() all of them\n        this.bp.log('Disconnecting all WebSocket clients');\n        this.messagesWsClients.forEach(chatConnection => {\n            chatConnection.wsClient.closeConnection();\n        });\n    }\n\n    logout() {\n        this.disconnect();\n        this.qtokenid = null;\n        this.api.qtokenid = null;\n\n        this.api.me = 'Guest';\n        this.me = 'Guest';\n        this.bp.me = 'Guest';\n        this.bp.qtokenid = null;\n\n        localStorage.removeItem('qtokenid');\n        localStorage.removeItem('me');\n\n        // Once we have performed the logout, emit the event\n        this.bp.emit('auth::logout');\n    }\n}\n\nClient.prototype.createWebSocketClient = createWebSocketClient;","// Function to create a WebSocket client for a given chatId\n// Assume \"this\" scope is bound to the `client` object\n// Currently used for chat rooms, not buddylist\nexport default function createWebSocketClient(chatId) {\n  // Check if a chatConnection already exists for this chatId\n  let chatConnection = this.messagesWsClients.get(chatId);\n  let reconnectAttempts = 0;\n  const maxReconnectAttempts = 999999; // Set to a high number for unlimited attempts\n  const maxBackoffDelay = 10000; // 10 seconds\n\n  // If a chatConnection exists, reuse its reconnectAttempts\n  if (chatConnection) {\n    console.log(`Reusing existing chatConnection for chatId: ${chatId}, reconnectAttempts: ${chatConnection.reconnectAttempts}`);\n    reconnectAttempts = chatConnection.reconnectAttempts;\n  } else {\n    console.log(`Creating new WebSocket client for chatId: ${chatId}`);\n  }\n\n  const wsClient = new WebSocket(\n    `${buddypond.messagesWsEndpoint}?me=${buddypond.me}&qtokenid=${buddypond.qtokenid}&chatId=${chatId}`\n  );\n\n  // Create or update chatConnection object\n  chatConnection = {\n    wsClient,\n    reconnectAttempts,\n    maxReconnectAttempts,\n    maxBackoffDelay\n  };\n  this.messagesWsClients.set(chatId, chatConnection);\n\n  let isIntentionallyClosed = false; // Flag to track intentional closure\n\n  // Named function for open event\n  function handleOpen() {\n    console.log('WebSocket connection opened to', chatId);\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    chatConnection.reconnectAttempts = 0; // Sync with chatConnection\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getHistory',\n        chatId: chatId,\n        profilePicture: this.bp.apps.buddylist.data.profileState.profilePicture,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getConnectedUsers',\n        chatId: chatId,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    // check for any queuedMessage\n    let queuedMessages = this.queuedMessages.get(chatId);\n    if (queuedMessages) {\n      console.log(\"SENDING QUEUED MESSAGE\", queuedMessages)\n      queuedMessages.forEach((message) => {\n        chatConnection.wsClient.send(JSON.stringify(message));\n\n      })\n    }\n    this.queuedMessages.set(chatId, null);\n\n    bp.emit('buddychat::connected', { chatId: chatId })\n\n    // Remark: attempt to set .aim-room-active class on the .aim-room-list-item-name, which is a child\n    // of the .aim-room-list-item with data-pond of chatId\n    // TODO: Move this code elsewhere, not in the client\n    // we may want to bp.emit('pond::connected') event instead\n    const chatWindow = this.bp.apps.ui.windowManager.getWindow('pond-chat');\n    if (chatWindow) {\n      const roomListItem = chatWindow.content.querySelector(`.aim-room-item[data-pond=\"${chatId}\"]`);\n      if (roomListItem) {\n        const roomNameElement = roomListItem.querySelector('.aim-room-list-item-name');\n        if (roomNameElement) {\n          roomNameElement.classList.add('aim-room-active');\n        }\n      }\n    }\n  }\n\n  // Named function for message event\n  async function handleMessage(event) {\n    try {\n      const parseData = JSON.parse(event.data);\n\n      switch (parseData.action) {\n        case 'message':\n          // console.log('WebSocket message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n        case 'connectedUsers':\n          // console.log('Connected users message received:', parseData);\n          bp.emit('pond::connectedUsers', parseData);\n          break;\n        case 'typing':\n          // console.log('Typing message received:', parseData);\n          bp.emit('buddy::isTyping', parseData.message);\n          break;\n        case 'rate-limit':\n          console.log('Rate limit exceeded:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message], retryAfter: parseData.retryAfter, severity: parseData.severity } });\n          console.error(parseData.severity, parseData.message.text);\n          if (parseData.severity == 3) {\n            alert('Please chill out.');\n          }\n\n          if (parseData.severity == 4) {\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/forbiddenRickRoll/forbiddenRickRoll.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n          }\n\n\n          if (parseData.severity >= 5) {\n\n\n            /*\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/hamster-dance/hamster-dance.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n            */\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/vortex/vortex.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n\n            // logout\n            // this.bp.logout();\n          }\n          break;\n\n        case 'getHistory':\n          // console.log('getHistory message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: parseData.messages } });\n          break;\n\n        case 'removeInstantMessage':\n          console.log('removeInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        case 'editInstantMessage':\n          console.log('editInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        default:\n          console.warn('Unknown action received:', parseData);\n          break;\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  }\n\n  // Named function for close event\n  function handleClose(event) {\n    console.log('WebSocket connection closed to', chatId, 'Code:', event.code, 'Reason:', event.reason);\n    console.log('reconnectAttempts:', chatConnection.reconnectAttempts);\n    console.log('isIntentionallyClosed:', isIntentionallyClosed);\n\n    // Only remove from Map if intentionally closed or max reconnect attempts reached\n    if (isIntentionallyClosed || chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.log(`Removing chatConnection for ${chatId} from messagesWsClients`);\n      this.messagesWsClients.delete(chatId);\n      console.log('Current WebSocket clients:', this.messagesWsClients);\n    }\n\n    // Reconnect only if the closure was not intentional and max attempts not reached\n    if (!isIntentionallyClosed && chatConnection.reconnectAttempts < chatConnection.maxReconnectAttempts) {\n      const delay = Math.min(\n        200 * Math.pow(2, chatConnection.reconnectAttempts) * (1 + 0.1 * Math.random()), // Exponential backoff with jitter\n        chatConnection.maxBackoffDelay\n      );\n      console.log(`Scheduling reconnect attempt ${chatConnection.reconnectAttempts + 1} for ${chatId} in ${delay}ms`);\n      setTimeout(() => {\n        reconnectAttempts++;\n        chatConnection.reconnectAttempts++; // Sync with chatConnection\n        createWebSocketClient.call(this, chatId); // Attempt to reconnect\n      }, delay);\n    } else if (chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.error(`Max reconnect attempts (${chatConnection.maxReconnectAttempts}) reached for ${chatId}. Giving up.`);\n    }\n  }\n\n  // Named function for error event\n  function handleError(event) {\n    console.error('WebSocket error for', chatId, event);\n    // Close the WebSocket to trigger the close handler\n    chatConnection.wsClient.close(1000, 'Error occurred');\n  }\n\n  // Add event listeners with named functions\n  wsClient.addEventListener('open', handleOpen.bind(this));\n  wsClient.addEventListener('message', handleMessage.bind(this));\n  wsClient.addEventListener('close', handleClose.bind(this));\n  wsClient.addEventListener('error', handleError.bind(this));\n\n  // Method to intentionally close the WebSocket\n  wsClient.closeConnection = function () {\n    isIntentionallyClosed = true;\n    console.log(`Intentionally closing WebSocket for ${chatId}`);\n    chatConnection.wsClient.close(1000, 'Normal closure');\n    // Remove event listeners to prevent memory leaks\n    chatConnection.wsClient.removeEventListener('open', handleOpen);\n    chatConnection.wsClient.removeEventListener('message', handleMessage);\n    chatConnection.wsClient.removeEventListener('close', handleClose);\n    chatConnection.wsClient.removeEventListener('error', handleError);\n  };\n\n  return wsClient;\n}"],"names":["Client","constructor","bp","options","this","config","host","api","buddypond","endpoint","messagesWsClients","Map","subscriptions","queuedMessages","keepaliveInterval","init","onmessage","event","handleWorkerMessage","onerror","console","error","worker","createWorker","log","data","startKeepaliveTimer","setInterval","keepAlive","stopKeepaliveTimer","clearInterval","sendWsMessage","chatId","message","chatConnection","get","wsClient","parts","split","buddyname","me","set","open","type","context","send","JSON","stringify","getConnectedUsers","alert","has","action","addSubscription","sort","join","createWebSocketClient","removeSubscription","readyState","closeConnection","connect","sendMessage","disconnect","forEach","logout","qtokenid","localStorage","removeItem","emit","prototype","reconnectAttempts","WebSocket","messagesWsEndpoint","maxReconnectAttempts","maxBackoffDelay","isIntentionallyClosed","handleOpen","profilePicture","apps","buddylist","profileState","chatWindow","ui","windowManager","getWindow","roomListItem","content","querySelector","roomNameElement","classList","add","async","handleMessage","parseData","parse","result","messages","retryAfter","severity","text","importModule","default","call","warn","handleClose","code","reason","delete","delay","Math","min","pow","random","setTimeout","handleError","close","addEventListener","bind","removeEventListener"],"mappings":"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"}