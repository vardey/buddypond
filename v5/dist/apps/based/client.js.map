{"version":3,"file":"client.js","sources":["../../../apps/based/client/client.js","../../../apps/based/client/lib/ws/createWebSocketClient.js"],"sourcesContent":["// Remark: We are migrating away from having client application, and instead moved each client to their own application's folder\n// This will be the client for messages, buddylist websocket is handled by apps/buddylist/lib/wsclient.js\n// TODO: Move this to /messages/client.js\nimport createWebSocketClient from './lib/ws/createWebSocketClient.js';\n\nexport default class Client {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.config = options.config || this.bp.config || {\n            host: \"\",\n            api: \"\",\n        };\n\n        this.api = buddypond;\n        this.api.endpoint = buddypond.endpoint;\n\n        this.messagesWsClients = new Map();\n\n        // Track active subscriptions\n        this.subscriptions = new Map();\n\n        // Messages waiting to be sent on connection\n        this.queuedMessages = new Map();\n\n        // Timer for keepalive\n        this.keepaliveInterval = null;\n    }\n\n    async init() {\n\n        /*\n        let config = {\n            onmessage: (event) => this.handleWorkerMessage(event),\n            onerror: (event) => console.error(\"Worker Error:\", event),\n        };\n\n        this.worker = await this.bp.createWorker('/apps/based/client/clientWorker.js', config);\n        this.worker.onmessage = (event) => {\n            this.bp.log('Message from worker:', event.data);\n            config.onmessage(event.data);\n        };\n\n        this.worker.onerror = (event) => {\n            console.error('Worker error:', event);\n            config.onerror(event);\n        };\n        */\n\n        return this;\n    }\n\n    startKeepaliveTimer() {\n        if (this.keepaliveInterval) return; // Prevent multiple intervals\n\n        this.keepaliveInterval = setInterval(() => {\n            //if (this.subscriptions.size > 0) {\n            buddypond.keepAlive();\n            this.bp.log('Keepalive ping sent');\n            //}\n        }, 30000); // 30 seconds interval\n    }\n\n    stopKeepaliveTimer() {\n        if (this.keepaliveInterval) {\n            clearInterval(this.keepaliveInterval);\n            this.keepaliveInterval = null;\n        }\n    }\n\n    sendWsMessage(chatId, message) {\n        let chatConnection = this.messagesWsClients.get(chatId);\n        if (!chatConnection || !chatConnection.wsClient || chatConnection.wsClient.readyState !== WebSocket.OPEN) {\n            console.log('buddypond.messagesWs not connected, will queue message and send on connect...', chatId, message);\n            // open the chat window, will send queued messags on connect\n            // TODO: buddylist should accept chatId\n            let parts = chatId.split('/');\n            let buddyname = parts[1];\n            if (buddyname === this.bp.me) {\n                buddyname = parts[2];\n            }\n            console.log('parts', parts)\n            console.log('buddyname', buddyname);\n            // TODO: allow for multiple queued messages\n            this.queuedMessages.set(chatId, [message]);\n            if (parts[0] === 'buddy') {\n                this.bp.open('buddylist', {\n                    type: 'buddy',\n                    context: buddyname,\n                })\n            }\n            return;\n        }\n        // Send the message via ws connection\n        chatConnection.wsClient.send(JSON.stringify(message));\n    }\n\n    getConnectedUsers(chatId) {\n        alert('getConnectedUsers called for ' + chatId);\n        // sends a getConnectedUsers webscket message to the server\n        this.bp.log('getConnectedUsers called');\n        if (this.messagesWsClients.has(chatId)) {\n            let chatConnection = this.messagesWsClients.get(chatId);\n            if (chatConnection && chatConnection.wsClient) {\n                this.bp.log('buddypond.messagesWsClients has', chatId, 'sending getConnectedUsers message');\n                chatConnection.wsClient.send(JSON.stringify({ action: 'getConnectedUsers' }));\n            } else {\n                this.bp.log('No WebSocket client found for', chatId);\n            }\n        }\n        else {\n            this.bp.log('No WebSocket client found for', chatId, 'unable to send getConnectedUsers message');\n        }\n\n    }\n\n    addSubscription(type, context) {\n        let chatId = type + '/' + context;\n\n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n        console.log(`subscribeMessages subscribing to ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (!this.messagesWsClients.has(chatId)) {\n            this.createWebSocketClient(chatId);\n        }\n    }\n\n    removeSubscription(type, context) {\n        let chatId = type + '/' + context;\n\n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n\n        console.log(`unsubscribeMessages unsubscribing from ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (this.messagesWsClients.has(chatId)) {\n            console.log(`buddypond.messagesWsClients has ${chatId}, closing connection`);\n            let chatConnection = this.messagesWsClients.get(chatId);\n            console.log('closing chatConnection', chatConnection);\n\n            console.log('Before close, readyState:', chatConnection.wsClient.readyState);\n            chatConnection.wsClient.closeConnection();\n        }\n    }\n\n    connect() {\n        // Moved to buddylist.client.connect()\n    }\n\n    sendMessage(message) {\n        this.bp.log('sendMessage', message);\n        message.me = this.api.me;\n    }\n\n    disconnect() {\n        // Iterate through all buddypond.messagesWsClients Map and closeConnection() all of them\n        this.bp.log('Disconnecting all WebSocket clients');\n        this.messagesWsClients.forEach(chatConnection => {\n            chatConnection.wsClient.closeConnection();\n        });\n    }\n\n    logout() {\n        this.disconnect();\n        this.qtokenid = null;\n        this.api.qtokenid = null;\n\n        this.api.me = 'Guest';\n        this.me = 'Guest';\n        this.bp.me = 'Guest';\n        this.bp.qtokenid = null;\n\n        localStorage.removeItem('qtokenid');\n        localStorage.removeItem('me');\n\n        // Once we have performed the logout, emit the event\n        this.bp.emit('auth::logout');\n    }\n}\n\nClient.prototype.createWebSocketClient = createWebSocketClient;","// Function to create a WebSocket client for a given chatId\n// Assume \"this\" scope is bound to the `client` object\n// Currently used for chat rooms, not buddylist\nexport default function createWebSocketClient(chatId) {\n  // Check if a chatConnection already exists for this chatId\n  let chatConnection = this.messagesWsClients.get(chatId);\n  let reconnectAttempts = 0;\n  const maxReconnectAttempts = 999999; // Set to a high number for unlimited attempts\n  const maxBackoffDelay = 10000; // 10 seconds\n\n  // If a chatConnection exists, reuse its reconnectAttempts\n  if (chatConnection) {\n    console.log(`Reusing existing chatConnection for chatId: ${chatId}, reconnectAttempts: ${chatConnection.reconnectAttempts}`);\n    reconnectAttempts = chatConnection.reconnectAttempts;\n  } else {\n    console.log(`Creating new WebSocket client for chatId: ${chatId}`);\n  }\n\n  const wsClient = new WebSocket(\n    `${buddypond.messagesWsEndpoint}?me=${buddypond.me}&qtokenid=${buddypond.qtokenid}&chatId=${chatId}`\n  );\n\n  // Create or update chatConnection object\n  chatConnection = {\n    wsClient,\n    reconnectAttempts,\n    maxReconnectAttempts,\n    maxBackoffDelay\n  };\n  this.messagesWsClients.set(chatId, chatConnection);\n\n  let isIntentionallyClosed = false; // Flag to track intentional closure\n\n  // Named function for open event\n  function handleOpen() {\n    console.log('WebSocket connection opened to', chatId);\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    chatConnection.reconnectAttempts = 0; // Sync with chatConnection\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getHistory',\n        chatId: chatId,\n        profilePicture: this.bp.apps.buddylist.data.profileState.profilePicture,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getConnectedUsers',\n        chatId: chatId,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    // check for any queuedMessage\n    let queuedMessages = this.queuedMessages.get(chatId);\n    if (queuedMessages) {\n      console.log(\"SENDING QUEUED MESSAGE\", queuedMessages)\n      queuedMessages.forEach((message) => {\n        chatConnection.wsClient.send(JSON.stringify(message));\n\n      })\n    }\n    this.queuedMessages.set(chatId, null);\n\n    bp.emit('buddychat::connected', { chatId: chatId })\n\n    // Remark: attempt to set .aim-room-active class on the .aim-room-list-item-name, which is a child\n    // of the .aim-room-list-item with data-pond of chatId\n    // TODO: Move this code elsewhere, not in the client\n    // we may want to bp.emit('pond::connected') event instead\n    const chatWindow = this.bp.apps.ui.windowManager.getWindow('pond-chat');\n    if (chatWindow) {\n      const roomListItem = chatWindow.content.querySelector(`.aim-room-item[data-pond=\"${chatId}\"]`);\n      if (roomListItem) {\n        const roomNameElement = roomListItem.querySelector('.aim-room-list-item-name');\n        if (roomNameElement) {\n          roomNameElement.classList.add('aim-room-active');\n        }\n      }\n    }\n\n      this.pingInterval = setInterval(() => {\n        if (wsClient && wsClient.readyState === WebSocket.OPEN) {\n          // console.log('Sending ping to buddylist WebSocket');\n\n          // auto-response level ping yield consistent `1006` websocket client errors across all browsers\n          // wsClient.send('ping'); // Matches server's setWebSocketAutoResponse(\"ping\", \"pong\")\n\n          // application level pings removes the 1006 errors, connections stay alive\n          wsClient.send(JSON.stringify({ action: 'ping' }) );\n        }\n      }, 25000);\n\n  }\n\n  // Named function for message event\n  async function handleMessage(event) {\n\n    if (event.data === 'pong') {\n      // console.log('Received pong from server');\n      return; // Ignore pong messages\n    }\n\n    try {\n      const parseData = JSON.parse(event.data);\n\n      switch (parseData.action) {\n        case 'pong':\n          // console.log('Received pong action from server:', parseData);\n          break;\n        case 'message':\n          // console.log('WebSocket message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n        case 'connectedUsers':\n          // console.log('Connected users message received:', parseData);\n          bp.emit('pond::connectedUsers', parseData);\n          break;\n        case 'typing':\n          // console.log('Typing message received:', parseData);\n          bp.emit('buddy::isTyping', parseData.message);\n          break;\n        case 'rate-limit':\n          console.log('Rate limit exceeded:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message], retryAfter: parseData.retryAfter, severity: parseData.severity } });\n          console.error(parseData.severity, parseData.message.text);\n          if (parseData.severity == 3) {\n            alert('Please chill out.');\n          }\n\n          if (parseData.severity == 4) {\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/forbiddenRickRoll/forbiddenRickRoll.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n          }\n\n\n          if (parseData.severity >= 5) {\n\n\n            /*\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/hamster-dance/hamster-dance.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n            */\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/vortex/vortex.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n\n            // logout\n            // this.bp.logout();\n          }\n          break;\n\n        case 'getHistory':\n          // console.log('getHistory message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: parseData.messages } });\n          break;\n\n        case 'removeInstantMessage':\n          console.log('removeInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        case 'editInstantMessage':\n          console.log('editInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n        case 'reactInstantMessage':\n          console.log('reactInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        default:\n          console.warn('Unknown action received:', parseData);\n          break;\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  }\n\n  // Named function for close event\n  function handleClose(event) {\n    console.log('WebSocket connection closed to', chatId, 'Code:', event.code, 'Reason:', event.reason);\n    console.log('reconnectAttempts:', chatConnection.reconnectAttempts);\n    console.log('isIntentionallyClosed:', isIntentionallyClosed);\n\n    clearInterval(this.pingInterval);\n\n    // Only remove from Map if intentionally closed or max reconnect attempts reached\n    if (isIntentionallyClosed || chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.log(`Removing chatConnection for ${chatId} from messagesWsClients`);\n      this.messagesWsClients.delete(chatId);\n      console.log('Current WebSocket clients:', this.messagesWsClients);\n    }\n\n    // Reconnect only if the closure was not intentional and max attempts not reached\n    if (!isIntentionallyClosed && chatConnection.reconnectAttempts < chatConnection.maxReconnectAttempts) {\n      const delay = Math.min(\n        200 * Math.pow(2, chatConnection.reconnectAttempts) * (1 + 0.1 * Math.random()), // Exponential backoff with jitter\n        chatConnection.maxBackoffDelay\n      );\n      console.log(`Scheduling reconnect attempt ${chatConnection.reconnectAttempts + 1} for ${chatId} in ${delay}ms`);\n      setTimeout(() => {\n        reconnectAttempts++;\n        chatConnection.reconnectAttempts++; // Sync with chatConnection\n        createWebSocketClient.call(this, chatId); // Attempt to reconnect\n      }, delay);\n    } else if (chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.error(`Max reconnect attempts (${chatConnection.maxReconnectAttempts}) reached for ${chatId}. Giving up.`);\n    }\n  }\n\n  // Named function for error event\n  function handleError(event) {\n    console.error('WebSocket error for', chatId, event);\n    // Close the WebSocket to trigger the close handler\n    chatConnection.wsClient.close(1000, 'Error occurred');\n  }\n\n  // Add event listeners with named functions\n  wsClient.addEventListener('open', handleOpen.bind(this));\n  wsClient.addEventListener('message', handleMessage.bind(this));\n  wsClient.addEventListener('close', handleClose.bind(this));\n  wsClient.addEventListener('error', handleError.bind(this));\n\n  // Method to intentionally close the WebSocket\n  wsClient.closeConnection = function () {\n    isIntentionallyClosed = true;\n    console.log(`Intentionally closing WebSocket for ${chatId}`);\n    chatConnection.wsClient.close(1000, 'Normal closure');\n    // Remove event listeners to prevent memory leaks\n    chatConnection.wsClient.removeEventListener('open', handleOpen);\n    chatConnection.wsClient.removeEventListener('message', handleMessage);\n    chatConnection.wsClient.removeEventListener('close', handleClose);\n    chatConnection.wsClient.removeEventListener('error', handleError);\n  };\n\n  return wsClient;\n}"],"names":["Client","constructor","bp","options","this","config","host","api","buddypond","endpoint","messagesWsClients","Map","subscriptions","queuedMessages","keepaliveInterval","init","startKeepaliveTimer","setInterval","keepAlive","log","stopKeepaliveTimer","clearInterval","sendWsMessage","chatId","message","chatConnection","get","wsClient","readyState","WebSocket","OPEN","console","parts","split","buddyname","me","set","open","type","context","send","JSON","stringify","getConnectedUsers","alert","has","action","addSubscription","sort","join","createWebSocketClient","removeSubscription","closeConnection","connect","sendMessage","disconnect","forEach","logout","qtokenid","localStorage","removeItem","emit","prototype","reconnectAttempts","messagesWsEndpoint","maxReconnectAttempts","maxBackoffDelay","isIntentionallyClosed","handleOpen","profilePicture","apps","buddylist","data","profileState","chatWindow","ui","windowManager","getWindow","roomListItem","content","querySelector","roomNameElement","classList","add","pingInterval","async","handleMessage","event","parseData","parse","result","messages","retryAfter","severity","error","text","importModule","default","call","warn","handleClose","code","reason","delete","delay","Math","min","pow","random","setTimeout","handleError","close","addEventListener","bind","removeEventListener"],"mappings":"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"}