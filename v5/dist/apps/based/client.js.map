{"version":3,"file":"client.js","sources":["../../../apps/based/client/client.js","../../../apps/based/client/lib/ws/createWebSocketClient.js"],"sourcesContent":["// Remark: We are migrating away from having client application, and instead moved each client to their own application's folder\n// This will be the client for messages, buddylist websocket is handled by apps/buddylist/lib/wsclient.js\n// TODO: Move this to /messages/client.js\nimport createWebSocketClient from './lib/ws/createWebSocketClient.js';\n\nexport default class Client {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.config = options.config || this.bp.config || {\n            host: \"\",\n            api: \"\",\n        };\n\n        this.api = buddypond;\n        this.api.endpoint = buddypond.endpoint;\n\n        this.messagesWsClients = new Map();\n\n        // Track active subscriptions\n        this.subscriptions = new Map();\n\n        // Messages waiting to be sent on connection\n        this.queuedMessages = new Map();\n\n        // Timer for keepalive\n        this.keepaliveInterval = null;\n    }\n\n    async init() {\n\n        /*\n        let config = {\n            onmessage: (event) => this.handleWorkerMessage(event),\n            onerror: (event) => console.error(\"Worker Error:\", event),\n        };\n\n        this.worker = await this.bp.createWorker('/apps/based/client/clientWorker.js', config);\n        this.worker.onmessage = (event) => {\n            this.bp.log('Message from worker:', event.data);\n            config.onmessage(event.data);\n        };\n\n        this.worker.onerror = (event) => {\n            console.error('Worker error:', event);\n            config.onerror(event);\n        };\n        */\n\n        return this;\n    }\n\n    startKeepaliveTimer() {\n        if (this.keepaliveInterval) return; // Prevent multiple intervals\n\n        this.keepaliveInterval = setInterval(() => {\n            //if (this.subscriptions.size > 0) {\n            buddypond.keepAlive();\n            this.bp.log('Keepalive ping sent');\n            //}\n        }, 30000); // 30 seconds interval\n    }\n\n    stopKeepaliveTimer() {\n        if (this.keepaliveInterval) {\n            clearInterval(this.keepaliveInterval);\n            this.keepaliveInterval = null;\n        }\n    }\n\n    sendWsMessage(chatId, message) {\n        let chatConnection = this.messagesWsClients.get(chatId);\n        if (!chatConnection || !chatConnection.wsClient) {\n            console.log('buddypond.messagesWs not connected, will queue message and send on connect...', chatId, message);\n            // open the chat window, will send queued messags on connect\n            // TODO: buddylist should accept chatId\n            let parts = chatId.split('/');\n            let buddyname = parts[1];\n            if (buddyname === this.bp.me) {\n                buddyname = parts[2];\n            }\n            console.log('parts', parts)\n            console.log('buddyname', buddyname);\n            // TODO: allow for multiple queued messages\n            this.queuedMessages.set(chatId, [message]);\n            if (parts[0] === 'buddy') {\n                this.bp.open('buddylist', {\n                    type: 'buddy',\n                    context: buddyname,\n                })\n            }\n            return;\n        }\n        // Send the message via ws connection\n        chatConnection.wsClient.send(JSON.stringify(message));\n    }\n\n    getConnectedUsers(chatId) {\n        alert('getConnectedUsers called for ' + chatId);\n        // sends a getConnectedUsers webscket message to the server\n        this.bp.log('getConnectedUsers called');\n        if (this.messagesWsClients.has(chatId)) {\n            let chatConnection = this.messagesWsClients.get(chatId);\n            if (chatConnection && chatConnection.wsClient) {\n                this.bp.log('buddypond.messagesWsClients has', chatId, 'sending getConnectedUsers message');\n                chatConnection.wsClient.send(JSON.stringify({ action: 'getConnectedUsers' }));\n            } else {\n                this.bp.log('No WebSocket client found for', chatId);\n            }\n        }\n        else {\n            this.bp.log('No WebSocket client found for', chatId, 'unable to send getConnectedUsers message');\n        }\n\n    }\n\n    addSubscription(type, context) {\n        let chatId = type + '/' + context;\n\n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n        console.log(`subscribeMessages subscribing to ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (!this.messagesWsClients.has(chatId)) {\n            this.createWebSocketClient(chatId);\n        }\n    }\n\n    removeSubscription(type, context) {\n        let chatId = type + '/' + context;\n\n        if (type === 'buddy') {\n            // If the context is a buddy, create a unique chatId for the tuple\n            let buddyNames = [buddypond.me, context].sort();\n            chatId = type + '/' + buddyNames.join('/');\n        }\n\n        console.log(`unsubscribeMessages unsubscribing from ${chatId}`);\n\n        // Check if an entry exists in the map\n        if (this.messagesWsClients.has(chatId)) {\n            console.log(`buddypond.messagesWsClients has ${chatId}, closing connection`);\n            let chatConnection = this.messagesWsClients.get(chatId);\n            console.log('closing chatConnection', chatConnection);\n\n            console.log('Before close, readyState:', chatConnection.wsClient.readyState);\n            chatConnection.wsClient.closeConnection();\n        }\n    }\n\n    connect() {\n        // Moved to buddylist.client.connect()\n    }\n\n    sendMessage(message) {\n        this.bp.log('sendMessage', message);\n        message.me = this.api.me;\n    }\n\n    disconnect() {\n        // Iterate through all buddypond.messagesWsClients Map and closeConnection() all of them\n        this.bp.log('Disconnecting all WebSocket clients');\n        this.messagesWsClients.forEach(chatConnection => {\n            chatConnection.wsClient.closeConnection();\n        });\n    }\n\n    logout() {\n        this.disconnect();\n        this.qtokenid = null;\n        this.api.qtokenid = null;\n\n        this.api.me = 'Guest';\n        this.me = 'Guest';\n        this.bp.me = 'Guest';\n        this.bp.qtokenid = null;\n\n        localStorage.removeItem('qtokenid');\n        localStorage.removeItem('me');\n\n        // Once we have performed the logout, emit the event\n        this.bp.emit('auth::logout');\n    }\n}\n\nClient.prototype.createWebSocketClient = createWebSocketClient;","// Function to create a WebSocket client for a given chatId\n// Assume \"this\" scope is bound to the `client` object\n// Currently used for chat rooms, not buddylist\nexport default function createWebSocketClient(chatId) {\n  // Check if a chatConnection already exists for this chatId\n  let chatConnection = this.messagesWsClients.get(chatId);\n  let reconnectAttempts = 0;\n  const maxReconnectAttempts = 999999; // Set to a high number for unlimited attempts\n  const maxBackoffDelay = 10000; // 10 seconds\n\n  // If a chatConnection exists, reuse its reconnectAttempts\n  if (chatConnection) {\n    console.log(`Reusing existing chatConnection for chatId: ${chatId}, reconnectAttempts: ${chatConnection.reconnectAttempts}`);\n    reconnectAttempts = chatConnection.reconnectAttempts;\n  } else {\n    console.log(`Creating new WebSocket client for chatId: ${chatId}`);\n  }\n\n  const wsClient = new WebSocket(\n    `${buddypond.messagesWsEndpoint}?me=${buddypond.me}&qtokenid=${buddypond.qtokenid}&chatId=${chatId}`\n  );\n\n  // Create or update chatConnection object\n  chatConnection = {\n    wsClient,\n    reconnectAttempts,\n    maxReconnectAttempts,\n    maxBackoffDelay\n  };\n  this.messagesWsClients.set(chatId, chatConnection);\n\n  let isIntentionallyClosed = false; // Flag to track intentional closure\n\n  // Named function for open event\n  function handleOpen() {\n    console.log('WebSocket connection opened to', chatId);\n    // Reset reconnect attempts on successful connection\n    reconnectAttempts = 0;\n    chatConnection.reconnectAttempts = 0; // Sync with chatConnection\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getHistory',\n        chatId: chatId,\n        profilePicture: this.bp.apps.buddylist.data.profileState.profilePicture,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    chatConnection.wsClient.send(\n      JSON.stringify({\n        action: 'getConnectedUsers',\n        chatId: chatId,\n        buddyname: buddypond.me,\n        qtokenid: buddypond.qtokenid,\n      })\n    );\n\n    // check for any queuedMessage\n    let queuedMessages = this.queuedMessages.get(chatId);\n    if (queuedMessages) {\n      console.log(\"SENDING QUEUED MESSAGE\", queuedMessages)\n      queuedMessages.forEach((message) => {\n        chatConnection.wsClient.send(JSON.stringify(message));\n\n      })\n    }\n    this.queuedMessages.set(chatId, null);\n\n    bp.emit('buddychat::connected', { chatId: chatId })\n\n    // Remark: attempt to set .aim-room-active class on the .aim-room-list-item-name, which is a child\n    // of the .aim-room-list-item with data-pond of chatId\n    // TODO: Move this code elsewhere, not in the client\n    // we may want to bp.emit('pond::connected') event instead\n    const chatWindow = this.bp.apps.ui.windowManager.getWindow('pond-chat');\n    if (chatWindow) {\n      const roomListItem = chatWindow.content.querySelector(`.aim-room-item[data-pond=\"${chatId}\"]`);\n      if (roomListItem) {\n        const roomNameElement = roomListItem.querySelector('.aim-room-list-item-name');\n        if (roomNameElement) {\n          roomNameElement.classList.add('aim-room-active');\n        }\n      }\n    }\n\n      this.pingInterval = setInterval(() => {\n        if (wsClient && wsClient.readyState === WebSocket.OPEN) {\n          // console.log('Sending ping to buddylist WebSocket');\n          wsClient.send('ping'); // Matches server's setWebSocketAutoResponse(\"ping\", \"pong\")\n        }\n      }, 30000);\n\n\n\n  }\n\n  // Named function for message event\n  async function handleMessage(event) {\n\n    if (event.data === 'pong') {\n      // console.log('Received pong from server');\n      return; // Ignore pong messages\n    }\n\n    try {\n      const parseData = JSON.parse(event.data);\n\n      switch (parseData.action) {\n        case 'message':\n          // console.log('WebSocket message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n        case 'connectedUsers':\n          // console.log('Connected users message received:', parseData);\n          bp.emit('pond::connectedUsers', parseData);\n          break;\n        case 'typing':\n          // console.log('Typing message received:', parseData);\n          bp.emit('buddy::isTyping', parseData.message);\n          break;\n        case 'rate-limit':\n          console.log('Rate limit exceeded:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message], retryAfter: parseData.retryAfter, severity: parseData.severity } });\n          console.error(parseData.severity, parseData.message.text);\n          if (parseData.severity == 3) {\n            alert('Please chill out.');\n          }\n\n          if (parseData.severity == 4) {\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/forbiddenRickRoll/forbiddenRickRoll.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n          }\n\n\n          if (parseData.severity >= 5) {\n\n\n            /*\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/hamster-dance/hamster-dance.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n            */\n\n            try {\n              let spellModule = await this.bp.importModule(`/v5/apps/based/spellbook/spells/vortex/vortex.js`, {}, false);\n              spellModule.default.call(this);\n            }\n            catch (error) {\n              console.log('Error importing spell module:', error);\n            }\n\n\n            // logout\n            // this.bp.logout();\n          }\n          break;\n\n        case 'getHistory':\n          // console.log('getHistory message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: parseData.messages } });\n          break;\n\n        case 'removeInstantMessage':\n          console.log('removeInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        case 'editInstantMessage':\n          console.log('editInstantMessage message received:', parseData);\n          bp.emit('buddy::messages', { result: { messages: [parseData.message] } });\n          break;\n\n        default:\n          console.warn('Unknown action received:', parseData);\n          break;\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  }\n\n  // Named function for close event\n  function handleClose(event) {\n    console.log('WebSocket connection closed to', chatId, 'Code:', event.code, 'Reason:', event.reason);\n    console.log('reconnectAttempts:', chatConnection.reconnectAttempts);\n    console.log('isIntentionallyClosed:', isIntentionallyClosed);\n\n    clearInterval(this.pingInterval);\n\n    // Only remove from Map if intentionally closed or max reconnect attempts reached\n    if (isIntentionallyClosed || chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.log(`Removing chatConnection for ${chatId} from messagesWsClients`);\n      this.messagesWsClients.delete(chatId);\n      console.log('Current WebSocket clients:', this.messagesWsClients);\n    }\n\n    // Reconnect only if the closure was not intentional and max attempts not reached\n    if (!isIntentionallyClosed && chatConnection.reconnectAttempts < chatConnection.maxReconnectAttempts) {\n      const delay = Math.min(\n        200 * Math.pow(2, chatConnection.reconnectAttempts) * (1 + 0.1 * Math.random()), // Exponential backoff with jitter\n        chatConnection.maxBackoffDelay\n      );\n      console.log(`Scheduling reconnect attempt ${chatConnection.reconnectAttempts + 1} for ${chatId} in ${delay}ms`);\n      setTimeout(() => {\n        reconnectAttempts++;\n        chatConnection.reconnectAttempts++; // Sync with chatConnection\n        createWebSocketClient.call(this, chatId); // Attempt to reconnect\n      }, delay);\n    } else if (chatConnection.reconnectAttempts >= chatConnection.maxReconnectAttempts) {\n      console.error(`Max reconnect attempts (${chatConnection.maxReconnectAttempts}) reached for ${chatId}. Giving up.`);\n    }\n  }\n\n  // Named function for error event\n  function handleError(event) {\n    console.error('WebSocket error for', chatId, event);\n    // Close the WebSocket to trigger the close handler\n    chatConnection.wsClient.close(1000, 'Error occurred');\n  }\n\n  // Add event listeners with named functions\n  wsClient.addEventListener('open', handleOpen.bind(this));\n  wsClient.addEventListener('message', handleMessage.bind(this));\n  wsClient.addEventListener('close', handleClose.bind(this));\n  wsClient.addEventListener('error', handleError.bind(this));\n\n  // Method to intentionally close the WebSocket\n  wsClient.closeConnection = function () {\n    isIntentionallyClosed = true;\n    console.log(`Intentionally closing WebSocket for ${chatId}`);\n    chatConnection.wsClient.close(1000, 'Normal closure');\n    // Remove event listeners to prevent memory leaks\n    chatConnection.wsClient.removeEventListener('open', handleOpen);\n    chatConnection.wsClient.removeEventListener('message', handleMessage);\n    chatConnection.wsClient.removeEventListener('close', handleClose);\n    chatConnection.wsClient.removeEventListener('error', handleError);\n  };\n\n  return wsClient;\n}"],"names":["Client","constructor","bp","options","this","config","host","api","buddypond","endpoint","messagesWsClients","Map","subscriptions","queuedMessages","keepaliveInterval","init","startKeepaliveTimer","setInterval","keepAlive","log","stopKeepaliveTimer","clearInterval","sendWsMessage","chatId","message","chatConnection","get","wsClient","console","parts","split","buddyname","me","set","open","type","context","send","JSON","stringify","getConnectedUsers","alert","has","action","addSubscription","sort","join","createWebSocketClient","removeSubscription","readyState","closeConnection","connect","sendMessage","disconnect","forEach","logout","qtokenid","localStorage","removeItem","emit","prototype","reconnectAttempts","WebSocket","messagesWsEndpoint","maxReconnectAttempts","maxBackoffDelay","isIntentionallyClosed","handleOpen","profilePicture","apps","buddylist","data","profileState","chatWindow","ui","windowManager","getWindow","roomListItem","content","querySelector","roomNameElement","classList","add","pingInterval","OPEN","async","handleMessage","event","parseData","parse","result","messages","retryAfter","severity","error","text","importModule","default","call","warn","handleClose","code","reason","delete","delay","Math","min","pow","random","setTimeout","handleError","close","addEventListener","bind","removeEventListener"],"mappings":"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"}