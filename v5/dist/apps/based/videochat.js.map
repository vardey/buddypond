{"version":3,"file":"videochat.js","sources":["../../../apps/based/videochat/videochat.js","../../../apps/based/videochat/lib/addLocalCamera.js","../../../apps/based/videochat/lib/enumerateDevices.js","../../../apps/based/videochat/lib/replaceStream.js"],"sourcesContent":["import enumerateDevices from \"./lib/enumerateDevices.js\";\nimport replaceStream from \"./lib/replaceStream.js\";\nimport addLocalCamera from \"./lib/addLocalCamera.js\";\n\n// let wsEndpoint = 'wss://videochat.buddypond.com/ws';\n// wsEndpoint = 'wss://192.168.200.59:8001/ws';\n\nexport default class VideoChat {\n    constructor(bp, options = {}) {\n        this.bp = bp;\n        this.webrtc = null;\n        this.localStream = null;\n        this.remoteStream = null;\n        this.callInProgress = false;\n        this.pollSignal = false;\n        this.devices = { videoinput: {}, audioinput: {}, audiooutput: {} };\n        this.alldevices = {};\n        this.currentBuddy = null;\n        this.websocket = null;\n        this.isHost = false;\n        this.remoteBuddy = null;\n        this.acceptedCall = false;\n        this.videoEnabled = true;\n        this.audioEnabled = true;\n        this.signalQueue = [];\n\n        return this;\n    }\n\n    async init() {\n        await this.bp.load('/v5/apps/based/videochat/videochat.css');\n        this.html = await this.bp.load('/v5/apps/based/videochat/videochat.html');\n        await this.bp.load('/desktop/assets/js/simplepeer.min.js');\n        this.bindEvents();\n    }\n\n    bindEvents() {\n        const d = $(document);\n        d.on('mousedown', '.startVideoCall', (e) => {\n            if (this.bp.me === 'anonymous') {\n                alert('You must create an account. Anonymous cannot make video calls');\n                return;\n            }\n            const buddyName = $('#videochat-buddyname').val();\n            const isHost = $('#videochat-isHost').is(':checked');\n            this.startCall(this.isHost, this.remoteBuddy);\n        });\n\n        d.on('mousedown', '.endVideoCall', (e) => {\n            const buddyName = $(e.target).closest('.buddy_message').data('context');\n            this.endCall(buddyName);\n        });\n\n        d.on('change', '.selectCamera', (e) => {\n            const newDeviceLabel = $(e.target).val();\n            this.replaceStream(newDeviceLabel, 'video');\n        });\n\n        d.on('change', '.selectAudio', (e) => {\n            // const newDevicecopy {\n            const newDeviceLabel = $(e.target).val();\n            this.replaceStream(newDeviceLabel, 'audio');\n        });\n\n        d.on('mousedown', '.toggleVideo', () => {\n            this.toggleVideo();\n        });\n\n        d.on('mousedown', '.toggleAudio', () => {\n            this.toggleAudio();\n        });\n    }\n\n    toggleVideo() {\n        if (!this.localStream) return;\n        this.videoEnabled = !this.videoEnabled;\n        this.localStream.getVideoTracks().forEach(track => {\n            track.enabled = this.videoEnabled;\n        });\n        const $toggleButton = $('.toggleVideo', this.videocallWindow.content);\n        $toggleButton.text(this.videoEnabled ? 'Turn Video Off' : 'Turn Video On');\n        $toggleButton.toggleClass('muted', !this.videoEnabled);\n    }\n\n    toggleAudio() {\n        if (!this.localStream) return;\n        this.audioEnabled = !this.audioEnabled;\n        this.localStream.getAudioTracks().forEach(track => {\n            track.enabled = this.audioEnabled;\n        });\n        const $toggleButton = $('.toggleAudio', this.videocallWindow.content);\n        $toggleButton.text(this.audioEnabled ? 'Mute Audio' : 'Unmute Audio');\n        $toggleButton.toggleClass('muted', !this.audioEnabled);\n    }\n\n    async open(options = {}) {\n        console.log('Opening Video Call Window', options);\n        let buddyname = options.context || null;\n\n        if (typeof options.isHost !== 'undefined') {\n            this.isHost = options.isHost;\n        }\n\n        if (!this.videocallWindow) {\n            this.videocallWindow = this.bp.apps.ui.windowManager.createWindow({\n                id: 'videochat-window',\n                title: 'Video Chat',\n                x: 50,\n                y: 100,\n                width: 800,\n                height: 480,\n                minWidth: 200,\n                minHeight: 200,\n                parent: $('#desktop')[0],\n                icon: '/desktop/assets/images/icons/icon_interdimensionalcable_64.png',\n                content: this.html,\n                resizable: true,\n                minimizable: true,\n                maximizable: true,\n                closable: true,\n                focusable: true,\n                maximized: false,\n                minimized: false,\n                onClose: () => this.close()\n            });\n        }\n\n        this.videocallWindow.focus();\n        this.remoteBuddy = buddyname;\n\n        if (options.acceptedCall) {\n            this.acceptedCall = true;\n        }\n\n        await this.addLocalCamera();\n        await this.initWebSocket(buddyname);\n\n        return this.videocallWindow; // TODO\n    }\n\n    async close() {\n        console.log('closing app', this)\n        await this.endCall(this.currentBuddy);\n        if (this.localStream) {\n            this.localStream.getTracks().forEach((track) => track.stop());\n            this.localStream = null;\n        }\n        if (this.videocallWindow) {\n            this.videocallWindow = null;\n        }\n        if (this.websocket) {\n            this.websocket.close();\n            this.websocket = null;\n        }\n    }\n\n    async startCall(isHost, buddyName) {\n        console.log('Starting call with', buddyName, 'isHost:', isHost);\n        if (!navigator.mediaDevices) {\n            alert('navigator.mediaDevices is undefined. Are you having HTTPS/SSL issues?');\n            return;\n        }\n\n        if (this.callInProgress) {\n            console.warn('Call already in progress');\n            return;\n        }\n\n        this.callInProgress = true;\n        this.currentBuddy = buddyName;\n        $('.endVideoCall').css('opacity', '1');\n        $('.startVideoCall').css('opacity', '0.4');\n        $('.buddyName', this.videocallWindow.content).html(buddyName);\n        $('.webrtcStatus', this.videocallWindow.content).html('Sending WebRTC Handshake Request...');\n        await this.initPeer(isHost, buddyName);\n    }\n\n    async endCall(buddyName) {\n        this.pollSignal = false;\n        this.signalQueue = [];\n\n        if (this.callTimer) {\n            clearInterval(this.callTimer);\n            this.callTimer = null;\n        }\n\n        if (this.videocallWindow.content) {\n            $('.startVideoCall').css('opacity', '1');\n            $('.endVideoCall').css('opacity', '0.4');\n            $('.webrtcStatus', this.videocallWindow.content).html(`Click Start Call to connect to ${buddyName}`);\n        }\n\n        if (this.remoteStream) {\n            this.remoteStream.getTracks().forEach((track) => track.stop());\n        }\n\n        if (this.webrtc) {\n            this.webrtc.destroy();\n            this.webrtc = null;\n        }\n\n        this.callInProgress = false;\n        this.currentBuddy = null;\n\n    }\n\n    async initWebSocket(buddyName) {\n        let wsUrl = buddypond.videoChatEndpoint + `?me=${encodeURIComponent(this.bp.me)}&buddyname=${encodeURIComponent(buddyName)}&qtokenid=${encodeURIComponent(this.bp.qtokenid)}`;\n        console.log('Connecting to WebSocket:', wsUrl);\n        this.websocket = new WebSocket(wsUrl);\n\n        this.currentBuddy = buddyName;\n\n        this.websocket.onmessage = async (event) => {\n            try {\n                console.log('WebSocket message received:', event.data);\n                const data = JSON.parse(event.data);\n\n                if (data.status === 'connected') {\n                    console.log('WebSocket connection opened:', { me: data.me, buddyname: data.buddyname });\n                    if (this.isHost) {\n                        $('.webrtcStatus', this.videocallWindow.content).html(`Waiting for ${buddyName} to connect...`);\n                    } else {\n                        $('.webrtcStatus', this.videocallWindow.content).html(`Click Start Call to accept call from ${buddyName}`);\n                    }\n                    return;\n                }\n\n                if (data.type === 'buddyready') {\n                    console.log(`Buddy ${buddyName} is ready for pairing`);\n                    $('.webrtcStatus', this.videocallWindow.content).html(`${buddyName} is ready! Starting call...`);\n                    $('.startVideoCall').css('opacity', '1');\n                    $('.startVideoCall').removeClass('disabled');\n                    if (this.isHost || this.acceptedCall) {\n                        await this.startCall(this.isHost, this.remoteBuddy);\n                    }\n                    return;\n                }\n\n                if (data.type === 'buddydisconnected') {\n                    console.log(`Buddy ${buddyName} disconnected`);\n                    $('.webrtcStatus', this.videocallWindow.content).html(`${buddyName} disconnected`);\n                    this.endCall(buddyName);\n                    return;\n                }\n\n                if (data.error) {\n                    console.error('WebSocket server error:', data.error, 'code:', data.code);\n                    $('.webrtcStatus', this.videocallWindow.content).html('Connection failed');\n                    this.endCall(buddyName);\n                    return;\n                }\n\n                if (data && this.webrtc) {\n                    console.log(`Received signal for ${buddyName}: ${data.type}`);\n                    this.webrtc.signal(data);\n\n                    if (this.signalQueue.length > 0 && data.type === this.signalQueue[0].signal.type) {\n                        this.signalQueue.shift();\n                        if (this.callTimersignalQueue.length === 0) {\n                            clearInterval(retryInterval);\n                        }\n                    }\n                }\n\n            } catch (err) {\n                console.error('Error parsing WebSocket message:', err);\n            }\n        };\n\n        this.websocket.onerror = (err) => {\n            console.error('WebSocket error:', err);\n            $('.webrtcStatus', this.videocallWindow.content).html('WebSocket connection failed');\n            this.endCall(buddyName);\n        };\n        // TODO: add a reconnection strategy for unexpected closures\n        this.websocket.onclose = (event) => {\n            console.log('WebSocket closed with code:', event.code, 'reason:', event.reason);\n            if (this.videocallWindow && this.videocallWindow.content) {\n                $('.webrtcStatus', this.videocallWindow.content).html('WebSocket connection closed');\n            }\n            this.endCall(buddyName);\n        };\n\n        try {\n            await new Promise((resolve, reject) => {\n                this.websocket.onopen = () => {\n                    console.log('WebSocket connection opened');\n                    resolve();\n                };\n                this.websocket.onerror = (err) => {\n                    reject(new Error('WebSocket connection failed'));\n                };\n            });\n        } catch (err) {\n            console.error('Failed to open WebSocket:', err);\n            throw err;\n        }\n    }\n\n    async initPeer(isHost, buddyName) {\n        console.log('Initializing WebRTC peer connection', isHost, buddyName);\n        $('.webrtcStatus', this.videocallWindow.content).html('Initiating Peer Connection...');\n        this.webrtc = new SimplePeer({\n            initiator: isHost,\n            config: {\n                iceServers: [\n                    { urls: 'stun:stun.l.google.com:19302' },\n                    // Add TURN server if available\n                    // { urls: 'turn:your.turn.server', username: 'username', credential: 'password' }\n                ]\n            }\n        });\n\n        let retryInterval = null;\n        const maxRetries = 9999;\n        const maxDelay = 8000;\n        const retryTimeout = 60000;\n        let retryCount = 0;\n        let startTime = Date.now();\n\n        const retrySignals = () => {\n            if (retryCount >= maxRetries || Date.now() - startTime > retryTimeout) {\n                console.log(`Stopped retrying for ${buddyName}: max retries or timeout reached`);\n                $('.webrtcStatus', this.videocallWindow.content).html('Failed to connect: Buddy not available');\n                this.endCall(buddyName);\n                return;\n            }\n\n            if (this.signalQueue.length === 0 || this.websocket.readyState !== WebSocket.OPEN) {\n                return;\n            }\n\n            const signalData = this.signalQueue[0];\n            console.log(`Retrying signal to ${buddyName} (attempt ${retryCount + 1}/${maxRetries})`);\n            $('.webrtcStatus', this.videocallWindow.content).html(`Waiting for ${buddyName} to accept the call...`);\n            this.websocket.send(JSON.stringify(signalData));\n        };\n\n        this.webrtc.on('stream', (stream) => {\n            console.log(`${buddyName} Camera Connected`);\n            const video = document.querySelector('#chatVideoBuddy');\n            video.srcObject = stream;\n            this.remoteStream = stream;\n        });\n\n        this.webrtc.on('signal', (data) => {\n            console.log(`Got signal`, data);\n            const signalData = { buddyname: buddyName, signal: data };\n            this.signalQueue.push(signalData);\n\n            if (this.websocket.readyState === WebSocket.OPEN) {\n                console.log(`Sending signal to ${buddyName}:`, signalData);\n                this.websocket.send(JSON.stringify(signalData));\n            }\n\n            if (!retryInterval) {\n                retryInterval = setInterval(() => {\n                    retrySignals();\n                }, Math.min(1000 * Math.pow(2, retryCount), maxDelay));\n            }\n        });\n\n        this.webrtc.on('error', (err) => {\n            console.error('WebRTC error:', err);\n            if (retryInterval) {\n                clearInterval(retryInterval);\n            }\n            this.restartPeerConnection();\n\n            //this.endCall(buddyName);\n        });\n\n        this.webrtc.on('close', () => {\n            console.log(`WebRTC connection with ${buddyName} closed`);\n            clearInterval(retryInterval);\n            this.endCall(buddyName);\n        });\n\n        this.webrtc.on('connect', async () => {\n            console.log('WebRTC peer connection established');\n            $('.webrtcStatus', this.videocallWindow.content).html('WebRTC peer connection established!');\n            clearInterval(retryInterval);\n            this.signalQueue.length = 0;\n            // Only add stream to WebRTC if not already added\n            if (this.localStream && this.webrtc) {\n                this.localStream.getVideoTracks().forEach(track => {\n                    track.enabled = this.videoEnabled;\n                });\n                this.localStream.getAudioTracks().forEach(track => {\n                    track.enabled = this.audioEnabled;\n                });\n                this.webrtc.addStream(this.localStream);\n            }\n            this.startCallTimer();\n        });\n\n        this.webrtc.on('iceConnectionStateChange', () => {\n            const iceState = this.webrtc._pc.iceConnectionState;\n            console.log(`ICE connection state: ${iceState}`);\n            $('.webrtcStatus', this.videocallWindow.content).html(`ICE state: ${iceState}`);\n            if (iceState === 'disconnected' || iceState === 'failed') {\n                this.restartPeerConnection();\n            }\n        });\n\n\n        $('.webrtcStatus', this.videocallWindow.content).html(`Waiting for ${buddyName} to connect...`);\n    }\n\n    startCallTimer() {\n        let seconds = 0;\n        this.callTimer = setInterval(() => {\n            seconds++;\n            const minutes = Math.floor(seconds / 60);\n            const secs = seconds % 60;\n            this.videocallWindow.setTitle(`Video Chat - (${minutes}:${secs.toString().padStart(2, '0')})`);\n        }, 1000);\n    }\n\n    restartPeerConnection() {\n        if (!this.callInProgress) return;\n        console.log('Restarting WebRTC connection...');\n        if (this.webrtc) {\n            this.webrtc.destroy();\n            this.webrtc = null;\n        }\n        setTimeout(() => {\n            this.initPeer(this.isHost, this.currentBuddy);\n        }\n        , 1000);\n    }\n\n}\n\nVideoChat.prototype.addLocalCamera = addLocalCamera;\nVideoChat.prototype.enumerateDevices = enumerateDevices;\nVideoChat.prototype.replaceStream = replaceStream;","export default async function addLocalCamera() {\n        try {\n            if (!this.localStream) {\n                console.log('Requesting local camera and microphone access');\n                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });\n                try {\n                    await this.enumerateDevices();\n                } catch (err) {\n                    console.error('Error enumerating devices:', err);\n                    $('.webrtcStatus', this.videocallWindow.content).html('Failed to access camera and microphone. Please check your browser settings.');\n                    return;\n                }\n                console.log('Local camera and microphone access granted');\n                // TODO: maybe enumerate here instead?\n                this.localStream = stream;\n                const video = document.querySelector('#chatVideoMe');\n                video.srcObject = stream;\n                video.muted = true;\n            }\n            // Apply current video and audio enabled states\n            this.localStream.getVideoTracks().forEach(track => {\n                track.enabled = this.videoEnabled;\n            });\n            this.localStream.getAudioTracks().forEach(track => {\n                track.enabled = this.audioEnabled;\n            });\n            // Only add stream to WebRTC if connection is active and not already added\n            if (this.webrtc && !this.webrtc._streams?.includes(this.localStream)) {\n                this.webrtc.addStream(this.localStream);\n            }\n        } catch (err) {\n            console.error('Error accessing local camera:', err);\n            let errorMessage = 'Failed to access camera and microphone.';\n            if (err.name === 'NotAllowedError') {\n                errorMessage = 'Camera and microphone access was denied. Please allow access in your browser settings.';\n            } else if (err.name === 'NotFoundError') {\n                errorMessage = 'No camera or microphone found. Please ensure devices are connected.';\n            }\n            $('.webrtcStatus', this.videocallWindow.content).html(errorMessage);\n        }\n    }","export default async function enumerateDevices(parent) {\n    try {\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        console.log('Devices:', devices);\n        $('.selectCamera', parent).html('');\n        $('.selectAudio', parent).html('');\n        devices.forEach((device) => {\n            this.alldevices[device.label] = device;\n            this.devices[device.kind] = this.devices[device.kind] || {};\n            this.devices[device.kind][device.label] = device;\n            if (device.kind === 'videoinput') {\n                $('.selectCamera', parent).append(\n                    `<option value=\"${device.label}\">${device.label}</option>`\n                );\n            }\n            if (device.kind === 'audioinput') {\n                $('.selectAudio', parent).append(\n                    `<option value=\"${device.label}\">${device.label}</option>`\n                );\n            }\n        });\n        console.log('videochat completed enumerateDevices', devices);\n    } catch (err) {\n        console.error('Error enumerating devices:', err);\n        throw err;\n    }\n}\n","export default async function replaceStream(label, kind) {\n    const newDevice = this.alldevices[label];\n    if (!newDevice) return;\n\n    try {\n        const constraints = kind === 'video' ? { video: { deviceId: newDevice.deviceId }, audio: false } : { audio: { deviceId: newDevice.deviceId }, video: false };\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        const newTrack = stream.getTracks()[0];\n\n        this.localStream.getTracks().forEach((track) => {\n            if (track.kind === kind) {\n                this.webrtc.replaceTrack(track, newTrack, this.localStream);\n                track.stop(); // Stop the old track\n            }\n        });\n\n        const video = document.querySelector('#chatVideoMe');\n        video.srcObject = stream;\n        $(`.select${kind === 'video' ? 'Camera' : 'Audio'}`, this.videocallWindow).val(newTrack.label);\n    } catch (err) {\n        console.error(`Error replacing ${kind} stream:`, err);\n    }\n}"],"names":["VideoChat","constructor","bp","options","this","webrtc","localStream","remoteStream","callInProgress","pollSignal","devices","videoinput","audioinput","audiooutput","alldevices","currentBuddy","websocket","isHost","remoteBuddy","acceptedCall","videoEnabled","audioEnabled","signalQueue","init","load","html","bindEvents","d","$","document","on","e","me","val","is","startCall","alert","buddyName","target","closest","data","endCall","newDeviceLabel","replaceStream","toggleVideo","toggleAudio","getVideoTracks","forEach","track","enabled","$toggleButton","videocallWindow","content","text","toggleClass","getAudioTracks","open","console","log","buddyname","context","apps","ui","windowManager","createWindow","id","title","x","y","width","height","minWidth","minHeight","parent","icon","resizable","minimizable","maximizable","closable","focusable","maximized","minimized","onClose","close","focus","addLocalCamera","initWebSocket","getTracks","stop","navigator","mediaDevices","warn","css","initPeer","callTimer","clearInterval","destroy","wsUrl","buddypond","videoChatEndpoint","encodeURIComponent","qtokenid","WebSocket","onmessage","async","event","JSON","parse","status","type","removeClass","error","code","signal","length","shift","callTimersignalQueue","retryInterval","err","onerror","onclose","reason","Promise","resolve","reject","onopen","Error","SimplePeer","initiator","config","iceServers","urls","startTime","Date","now","retrySignals","readyState","OPEN","signalData","send","stringify","stream","querySelector","srcObject","push","setInterval","Math","min","pow","restartPeerConnection","addStream","startCallTimer","iceState","_pc","iceConnectionState","seconds","minutes","floor","secs","setTitle","toString","padStart","setTimeout","prototype","getUserMedia","video","audio","enumerateDevices","muted","_streams","includes","errorMessage","name","device","label","kind","append","newDevice","constraints","deviceId","newTrack","replaceTrack"],"mappings":"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"}