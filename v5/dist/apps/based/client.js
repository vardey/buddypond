class e{constructor(e,s={}){this.bp=e,this.config=s.config||this.bp.config||{host:"",api:""},this.api=buddypond,this.api.endpoint=`${this.config.api}`,this.messagesWsClients=new Map,this.subscriptions=new Map,this.queuedMessages=new Map,this.keepaliveInterval=null}async init(){return this}startKeepaliveTimer(){this.keepaliveInterval||(this.keepaliveInterval=setInterval((()=>{buddypond.keepAlive(),this.bp.log("Keepalive ping sent")}),3e4))}stopKeepaliveTimer(){this.keepaliveInterval&&(clearInterval(this.keepaliveInterval),this.keepaliveInterval=null)}sendWsMessage(e,s){let t=this.messagesWsClients.get(e);if(!t||!t.wsClient){console.log("buddypond.messagesWs not connected, will queue message and send on connect...",e,s);let t=e.split("/"),n=t[1];return n===this.bp.me&&(n=t[2]),console.log("parts",t),console.log("buddyname",n),this.queuedMessages.set(e,[s]),void("buddy"===t[0]&&this.bp.open("buddylist",{type:"buddy",context:n}))}t.wsClient.send(JSON.stringify(s))}getConnectedUsers(e){if(alert("getConnectedUsers called for "+e),this.bp.log("getConnectedUsers called"),this.messagesWsClients.has(e)){let s=this.messagesWsClients.get(e);s&&s.wsClient?(this.bp.log("buddypond.messagesWsClients has",e,"sending getConnectedUsers message"),s.wsClient.send(JSON.stringify({action:"getConnectedUsers"}))):this.bp.log("No WebSocket client found for",e)}else this.bp.log("No WebSocket client found for",e,"unable to send getConnectedUsers message")}addSubscription(e,s){let t=e+"/"+s;if("buddy"===e){t=e+"/"+[buddypond.me,s].sort().join("/")}console.log(`subscribeMessages subscribing to ${t}`),this.messagesWsClients.has(t)||this.createWebSocketClient(t)}removeSubscription(e,s){let t=e+"/"+s;if("buddy"===e){t=e+"/"+[buddypond.me,s].sort().join("/")}if(console.log(`unsubscribeMessages unsubscribing from ${t}`),this.messagesWsClients.has(t)){console.log(`buddypond.messagesWsClients has ${t}, closing connection`);let e=this.messagesWsClients.get(t);console.log("closing chatConnection",e),console.log("Before close, readyState:",e.wsClient.readyState),e.wsClient.closeConnection()}}connect(){}sendMessage(e){this.bp.log("sendMessage",e),e.me=this.api.me}disconnect(){this.bp.log("Disconnecting all WebSocket clients"),this.messagesWsClients.forEach((e=>{e.wsClient.closeConnection()}))}logout(){this.disconnect(),this.qtokenid=null,this.api.qtokenid=null,this.api.me="Guest",this.me="Guest",this.bp.me="Guest",this.bp.qtokenid=null,localStorage.removeItem("qtokenid"),localStorage.removeItem("me"),this.bp.emit("auth::logout")}}e.prototype.createWebSocketClient=function e(s){let t=this.messagesWsClients.get(s),n=0;t?(console.log(`Reusing existing chatConnection for chatId: ${s}, reconnectAttempts: ${t.reconnectAttempts}`),n=t.reconnectAttempts):console.log(`Creating new WebSocket client for chatId: ${s}`);const o=new WebSocket(`${buddypond.messagesWsEndpoint}?me=${buddypond.me}&qtokenid=${buddypond.qtokenid}&chatId=${s}`);t={wsClient:o,reconnectAttempts:n,maxReconnectAttempts:999999,maxBackoffDelay:1e4},this.messagesWsClients.set(s,t);let i=!1;function l(){console.log("WebSocket connection opened to",s),n=0,t.reconnectAttempts=0,t.wsClient.send(JSON.stringify({action:"getHistory",chatId:s,profilePicture:this.bp.apps.buddylist.data.profileState.profilePicture,buddyname:buddypond.me,qtokenid:buddypond.qtokenid})),t.wsClient.send(JSON.stringify({action:"getConnectedUsers",chatId:s,buddyname:buddypond.me,qtokenid:buddypond.qtokenid}));let e=this.queuedMessages.get(s);e&&(console.log("SENDING QUEUED MESSAGE",e),e.forEach((e=>{t.wsClient.send(JSON.stringify(e))}))),this.queuedMessages.set(s,null),bp.emit("buddychat::connected",{chatId:s});const o=this.bp.apps.ui.windowManager.getWindow("pond-chat");if(o){const e=o.content.querySelector(`.aim-room-item[data-pond="${s}"]`);if(e){const s=e.querySelector(".aim-room-list-item-name");s&&s.classList.add("aim-room-active")}}}async function c(e){try{const s=JSON.parse(e.data);switch(s.action){case"message":bp.emit("buddy::messages",{result:{messages:[s.message]}});break;case"connectedUsers":bp.emit("pond::connectedUsers",s);break;case"typing":bp.emit("buddy::isTyping",s.message);break;case"rate-limit":if(console.log("Rate limit exceeded:",s),bp.emit("buddy::messages",{result:{messages:[s.message],retryAfter:s.retryAfter,severity:s.severity}}),console.error(s.severity,s.message.text),3==s.severity&&alert("Please chill out."),4==s.severity)try{(await this.bp.importModule("/v5/apps/based/spellbook/spells/forbiddenRickRoll/forbiddenRickRoll.js",{},!1)).default.call(this)}catch(e){console.log("Error importing spell module:",e)}if(s.severity>=5)try{(await this.bp.importModule("/v5/apps/based/spellbook/spells/vortex/vortex.js",{},!1)).default.call(this)}catch(e){console.log("Error importing spell module:",e)}break;case"getHistory":bp.emit("buddy::messages",{result:{messages:s.messages}});break;case"removeInstantMessage":console.log("removeInstantMessage message received:",s),bp.emit("buddy::messages",{result:{messages:[s.message]}});break;case"editInstantMessage":console.log("editInstantMessage message received:",s),bp.emit("buddy::messages",{result:{messages:[s.message]}});break;default:console.warn("Unknown action received:",s)}}catch(e){console.error("Error parsing WebSocket message:",e)}}function a(o){if(console.log("WebSocket connection closed to",s,"Code:",o.code,"Reason:",o.reason),console.log("reconnectAttempts:",t.reconnectAttempts),console.log("isIntentionallyClosed:",i),(i||t.reconnectAttempts>=t.maxReconnectAttempts)&&(console.log(`Removing chatConnection for ${s} from messagesWsClients`),this.messagesWsClients.delete(s),console.log("Current WebSocket clients:",this.messagesWsClients)),!i&&t.reconnectAttempts<t.maxReconnectAttempts){const o=Math.min(200*Math.pow(2,t.reconnectAttempts)*(1+.1*Math.random()),t.maxBackoffDelay);console.log(`Scheduling reconnect attempt ${t.reconnectAttempts+1} for ${s} in ${o}ms`),setTimeout((()=>{n++,t.reconnectAttempts++,e.call(this,s)}),o)}else t.reconnectAttempts>=t.maxReconnectAttempts&&console.error(`Max reconnect attempts (${t.maxReconnectAttempts}) reached for ${s}. Giving up.`)}function r(e){console.error("WebSocket error for",s,e),t.wsClient.close(1e3,"Error occurred")}return o.addEventListener("open",l.bind(this)),o.addEventListener("message",c.bind(this)),o.addEventListener("close",a.bind(this)),o.addEventListener("error",r.bind(this)),o.closeConnection=function(){i=!0,console.log(`Intentionally closing WebSocket for ${s}`),t.wsClient.close(1e3,"Normal closure"),t.wsClient.removeEventListener("open",l),t.wsClient.removeEventListener("message",c),t.wsClient.removeEventListener("close",a),t.wsClient.removeEventListener("error",r)},o};export{e as default};
//# sourceMappingURL=client.js.map
